import Crypto
from Crypto.Util.number import isPrime
from gmpy2 import mpz, powmod, invert, mul, add, f_mod, qdiv
from functools import partial
import importlib

from .elgamal import ElGamalCrypto
from .algebra import Group, GroupElement
from .exceptions import (AlgebraError, WrongCryptoError, WeakCryptoError,
    InvalidVoteError, InvalidStructureError, InvalidSignatureError,
    InvalidEncryptionError)
from .constants import (V_FINGERPRINT, V_PREVIOUS, V_ELECTION, V_ZEUS_PUBLIC,
    V_TRUSTEES, V_CANDIDATES, V_MODULUS, V_GENERATOR, V_ORDER, V_ALPHA, V_BETA,
    V_COMMITMENT, V_CHALLENGE, V_RESPONSE, V_COMMENTS, V_INDEX, V_CAST_VOTE,
    V_AUDIT_REQUEST, V_PUBLIC_AUDIT, V_PUBLIC_AUDIT_FAILED)
from utils import (int_from_bytes, hash_nums, hash_texts, random_integer,
    hash_encode, hash_decode, extract_value)


class ModPrimeElement(GroupElement):
    """
    Element of the multiplicative group Z*_p = Z_p - {0}, p > 2 prime
    """

    __slots__ = ('__value', '__modulus', '__inverse')

    def __init__(self, value, modulus):
        """
        :type value: mpz
        :type modulus: mpz
        """
        self.__value = value % modulus
        self.__modulus = modulus

        # Set here modular inverse (costly to compute everytime)
        try:
            self.__inverse = invert(self.__value, self.__modulus)
        except ZeroDivisionError:
            pass                               # Set nothing if it doesn't exist


    @property
    def value(self):
        """
        :rtype: mpz
        """
        return self.__value

    def reset_value(self, value):
        """
        :type value: mpz
        """
        self.__value = value % self.__modulus

    def reduce_value(self, difference=1):
        """
        Reduces modp the value of the element

        :type difference: int
        """
        self.__value = (self.__value - difference) % self.__modulus

    def mirror_value(self):
        """
        Reflects mod p the value of the element, i.e., if the element's
        initial value is z, then after mirroring it is equal to

        -z (mod p)
        """
        self.__value = - self.__value % self.__modulus

    @property
    def modulus(self):
        """
        :rtype: mpz
        """
        return self.__modulus

    @property
    def inverse(self):
        """
        :rtype: ModPrimeElement
        """
        return self.__class__(self.__inverse, self.__modulus)


    @property
    def bit_length(self):
        """
        :rtype: int
        """
        return self.__value.bit_length()


    def __repr__(self):
        """
        :rtype: str
        """
        return str(self.__value)

    def __hash__(self):
        """
        :rtype: int
        """
        return hash(repr(self))

    def __eq__(self, other):
        """
        :type other: ModPrimeElement or mpz
        """
        if isinstance(other, self.__class__):
            return self.__value == other.value
        else:
            return self.__value == other


    def __mul__(self, other):
        """
        :type other: ModPrimeElement
        """
        __modulus = self.__modulus
        result = self.__value * other.value % __modulus
        return self.__class__(result, __modulus)

    def __pow__(self, exp):
        """
        :type exp: mpz
        :rtype: ModPrimeElement
        """
        __modulus = self.__modulus

        # ~ result = self.__value ** exp % __modulus ---> "...outrageous exponent"
        # ~ Use gmpy2.powmod instead in order to avoid overflow in mpz type
        result = powmod(self.__value, exp, __modulus)
        return self.__class__(result, __modulus)


    def clone(self):
        """
        :rtype: ModPrimeElement
        """
        return self.__class__(self.__value, self.__modulus)


    def contained_in(self, group):
        """
        Checks if the element is contained the provided subgroup of Z*_p

        :type: Group
        :rtype: bool
        """
        if isinstance(group, ModPrimeSubgroup) and group.modulus == self.__modulus:
            # Algebraic fact: given the q-subgroup C of Z*_p, p > 2 prime,
            # a mod p element x is contained in C iff x ^ q = 1
            return self ** group.order == 1
        return False


class ModPrimeSubgroup(Group):
    """
    Subgroup of the multiplicative group Z*_p = Z_p - {0}, p > 2 prime

    There is one such group of order q for each divisor 0 < q < p - 1 of p - 1
    and is generated by the r-power, r = (p - 1)/q, of any primitive in Z*_p

    E.g., the default value r = 2 yields the group of quadratic residues modp
    """


    __slots__ = ('__modulus', '__order', '__generator', '__Element')

    def __init__(self, modulus, root_order=2):
        """
        :type modulus: mpz
        :type root_order: mpz
        :generator: ModPrimeElement
        """
        modulus = modulus
        root_order = root_order

        if modulus <= 2 or not isPrime(modulus):
            e = 'Provided modulus is not an odd prime'
            raise AlgebraError(e)

        if root_order <= 0 or root_order >= modulus:
            e = 'Provided order of unit root is not in the allowed range'
            raise AlgebraError(e)

        order, s = divmod(modulus - 1, root_order)

        if s != 0:
            e = 'Provided order of unit root does not divide the multiplicative group\'s order'
            raise AlgebraError(e)

        self.__modulus = modulus
        self.__order = order

        self.__Element = ModPrimeElement
        self.__unit = mpz(1)


    def __repr__(self):
        """
        :rtype: str
        """
        return '%s (%d, %d)' % (self.__class__, self.__modulus, self.__order)

    def __hash__(self):
        """
        :rtype: str
        """
        return hash(repr(self))


    @property
    def modulus(self):
        """
        :rtype: mpz
        """
        return self.__modulus

    @property
    def order(self):
        """
        :rtype: mpz
        """
        return self.__order

    @property
    def generator(self):
        """
        :rtype: ModPrimeElement
        """
        try:
            return self.__generator
        except AttributeError:
            e = 'No generator has been yet specified for this group'
            raise AlgebraError(e)

    def parameters(self):
        """
        """
        p = self.__modulus
        q = self.__order
        g = self.__generator.value
        return p, q, g


    @property
    def Element(self):
        """
        :rtype: class
        """
        return self.__Element

    def unit(self):
        """
        Returns the unit element of the group (i.e., the neutral
        element with respect to the group operation)

        :rtype: ModPrimeElement
        """
        return self.Element(self.__unit, self.__modulus)


    def set_generator(self, generator):
        """
        :type generator: ModPrimeElement or mpz
        """
        Element = self.Element
        if isinstance(generator, Element):
            self.__generator = generator
        else:
            self.__generator = Element(generator, self.__modulus)

    def generate(self, exponent):
        """
        :type exponent: mpz
        :rtype: ModPrimeElement
        """
        return self.__generator ** exponent


    def add_exponents(self, *args):
        """
        :type *args: mpz
        :rtype: mpz
        """
        return sum(args) % self.__order

    def random_exponent(self, min=2):
        """
        Returns a random exponent >= `min`, bounded by the group's order

        :rtype: mpz
        """
        exponent = random_integer(min, self.__order)
        return mpz(exponent)

    def exponent_from_texts(self, *texts):
        """
        :type *texts: str
        :rtype: mpz
        """
        __p, __q, __g = self.parameters()

        hashed_params = hash_nums(__p, __q, __g).hex()
        hashed_texts = hash_texts(hashed_params, *texts)
        exponent = int_from_bytes(hashed_texts)
        exponent = f_mod(exponent, __q)

        return exponent


    def random_element(self):
        """
        :rtype: ModPrimeElement
        """
        random_exp = self.random_exponent()
        return self.__generator ** random_exp

    def element_from_texts(self, *texts):
        """
        :type *texts: str
        :rtype: ModPrimeElement
        """
        exp = self.exponent_from_texts(*texts)
        return self.generate(exp)


    def fiatshamir(self, *elements):
        """
        The output of this method is only involved in exponent operations

        :type: mpz or ModePrimeElement
        :rtype: mpz
        """

        __p, __q, __g = self.parameters()

        elements = (_.value if isinstance(_, ModPrimeElement) else _ for _ in elements)

        digest = hash_nums(__p, __q, __g, *elements)
        reduced = int_from_bytes(digest)
        output = self.generate(reduced).value

        return output       # g ^ ( H( p | g | q | elements)  modq )  modp


    def contains(self, element):
        """
        Checks if the group contains the provided element of Z*_p

        :type element: GroupElement
        :rtype: bool
        """
        if isinstance(element, ModPrimeElement) and element.modulus == self.__modulus:
            # Algebraic fact: given the q-subgroup C of Z*_p, p > 2 prime,
            # an mod p element x is contained in C iff x ^ q = 1
            return element ** self.__order == 1
        return False


    def encode_integer(self, integer):
        """
        Encodes the provided `integer` x from the range 0 < x + 1 < q - 1
        as a modp element with the value

        (x + 1) mod p

        if this happens to be r-residue modp, otherwise with the mirror value

        - (x + 1) mod p

        .. raises:: AlgebraError if x is not in the specified range

        :type integer: int
        :rtype: ModPrimeElement

        .. note:: The result of this encoding is not necessarilly contained
        in the present group, even after mirroring its value modp
        """
        __modulus, __order, _ = self.parameters()

        integer += 1
        if not 0 < integer < __order:
            e = 'Provided integer is not in the allowed range'
            raise AlgebraError(e)

        value = mpz(integer)

        encoded = self.Element(value, __modulus)
        if not self.contains(encoded):
            encoded.mirror_value()

        return encoded

    def decode_with_randomness(self, encoded):
        """
        Given a mod p element with value z, it returns the element

        z - 1 (mod p)

        if z happens to be contained in the present subgroup;
        otherwise the element

        (-z (mod p)) - 1 (mod p)

        is returned

        :type element: ModPrimeElement
        :rtype: int
        """
        decoded = encoded.clone()

        if not decoded.contained_in(self):
            decoded.mirror_value()
        decoded.reduce_value()

        return decoded


class ModPrimeCrypto(ElGamalCrypto):
    """
    ElGamal cryptosystem over the group of r-residues mod p, p > 2 prime.
    Defaults to r = 2, yielding the group of quadratic residues mod p
    """

    MIN_MOD_SIZE = 2048
    MIN_GEN_SIZE = 2000


    __slots__ = ('__group', '__GroupElement',

        # ~ Group params included for mpz computations
        # ~ outside the group interface
        '__modulus', '__order', '__generator')


    def __init__(self, modulus, primitive, root_order=2, prime_order=True,
            min_mod_size=None, min_gen_size=None, allow_weakness=False):
        """
        Assumes the provided `primitive` g0 to be a primitive mod p, i.e.,
        a generator of the multiplicative group Z*_p or, equivalently, a
        primitive (p - 1)-root of 1, i.e.,

        g0 ^ (p - 1) = 1 and g0 ^ k != 1 for all 0 < k < p - 1

        :type modulus: int
        :type primitive: int
        :type root_order: int
        :type prime_order: bool
        :type min_mod_size: int
        :type min_gen_size: int
        :type allow_weakness: bool
        """

        # Type conversion

        modulus = mpz(modulus)                                   # p
        primitive = ModPrimeElement(mpz(primitive), modulus)     # g0
        root_order = mpz(root_order)                             # r

        # Resolve group

        try:
            group = ModPrimeSubgroup(modulus, root_order)
        except AlgebraError:
            raise

        self.__group = group
        self.__modulus = group.modulus
        self.__order = group.order

        self.__GroupElement = ModPrimeElement

        # Resolve generator

        # Algebraic fact: given a primitive g0 of Z*_p, p > 2 smooth, and 1 < r < p - 1
        # with r | p - 1, then g0 ^ r generates the q-subgroup of Z*_p, q = (p - 1)/r
        generator = primitive ** root_order

        try:
            self.__group.set_generator(generator)
        except AlgebraError:
            raise
        else:
            group = self.__group

        self.__generator = group.generator.value

        # System validation

        if root_order==2 and modulus % 4 != 3:
            # Algebraic fact: the condition p = 3 mod 4 guarantees direct
            # solvability of the congruence x ^ 2 = a (mod p), a in Z*_p,
            # allowing for efficient verification of quadratic residues
            e = 'Provided modulus is not 3 mod 4'
            raise WrongCryptoError(e)

        if prime_order and not isPrime(group.order):
            e = 'Order of the requested group is not prime'
            raise WrongCryptoError(e)

        if not allow_weakness:

            MIN_MOD_SIZE = min_mod_size or self.__class__.MIN_MOD_SIZE
            if modulus.bit_length() < MIN_MOD_SIZE:
                e = 'Provided modulus is < %d bits long' % MIN_MOD_SIZE
                raise WeakCryptoError(e)

            MIN_GEN_SIZE = min_gen_size or self.__class__.MIN_GEN_SIZE
            if group.generator.bit_length < MIN_GEN_SIZE:
                e = 'Generator is < %d bits long' % MIN_GEN_SIZE
                raise WeakCryptoError(e)


    # Cryptosystem

    @property
    def parameters(self):
        """
        :rtype: dict
        """
        p, q, g = self._parameters()

        return {'modulus': int(p), 'order': int(q), 'generator': int(g)}

    def _parameters(self):
        """
        Returns the modulus p, order q and fixed generator g of the
        underlying group as a tuple of the form (mpz, mpz, mpz)

        :rtype: tuple
        """
        p = self.__modulus
        q = self.__order
        g = self.__generator
        return p, q, g

    @property
    def group(self):
        """
        :rtype: ModPrimeSubgroup
        """
        return self.__group

    @property
    def GroupElement(self):
        """
        :rtype: class
        """
        return self.__GroupElement


    # Elections API

    def create_zeus_keypair(self, zeus_secret_key=None):
        """
        Creates and returns a key pair for zeus

        :type zeus_secret_key: mpz
        :rtype: dict
        """
        zeus_keypair = self.keygen(zeus_secret_key)
        return zeus_keypair

    def generate_trustees(self, nr_trustees):
        """
        :type nr_trustees: int
        :rtype: list[dict]
        """
        keypairs = [self.keygen() for _ in range(nr_trustees)]
        trustees = [self._extract_public(keypair) for keypair in keypairs]
        return trustees

    def _reprove_trustee(self, trustee_keypair):
        """
        :type trustee_keypair: dict
        :rtype: dict
        """
        private_key, public_key = self._extract_keypair(trustee_keypair)
        public_key = self._extract_value(public_key)
        proof = self._schnorr_proof(private_key, public_key)
        return proof

    def compute_election_key(self, trustees, zeus_keypair):
        """
        Computes and returns the election public key

        :type trustees: list[dict]
        :type zeus_keypair: dict
        :rtype: dict
        """
        public_shares = self._extract_public_shares(trustees)
        zeus_public_key = self._extract_public_value(zeus_keypair)
        combined = self._combine_public_keys(zeus_public_key, public_shares)
        election_key = self._set_public_key_from_element(combined)
        return election_key

    def validate_election_key(self, election_key, trustees, zeus_keypair):
        """
        :type election_key: dict
        :type trustees: list[dict]
        :type zeus_keypair: dict
        :rtype: bool
        """
        election_key = self._extract_value(election_key)
        test_key = self.compute_election_key(trustees, zeus_keypair)
        return election_key == self._extract_value(test_key)


    def _extract_public_shares(self, trustees):
        """
        Extracts public keys of the provided trustees as group elements
        and returns them in a list

        :type trustees: list[dict]
        :rtype: list[ModPrimeElement]
        """
        public_shares = [self._extract_value(public_key) for public_key in trustees]
        return public_shares


    def _encode_integer(self, integer):
        """
        :type integer: int
        :rtype: ModPrimeElement
        """
        element = self.group.encode_integer(integer)
        return element

    def _set_vote(self, voter, encrypted, fingerprint, audit_code=None, publish=None,
            voter_secret=None, previous=None, index=None, status=None, plaintext=None):
        """
        :type voter:
        :type encrypted: dict
        :type fingerprint: bytes
        :type audit_code:
        :type publish:
        :type voter_sercret:
        :type previous:
        :type index:
        :type status:
        :type plaintext: int
        :rtype: dict
        """
        vote = {
            'voter': str(voter),
            'encrypted': encrypted,
            'fingerprint': hash_decode(fingerprint)
        }

        if audit_code:
            vote['audit_code'] = int(audit_code)
        if publish:
            vote['voter_secret'] = str(voter_secret)    # str(int(voter_secret))
        if previous:
            vote['index'] = str(index)
        if status:
            vote['status'] = status
        if plaintext:
            vote['plaintext'] = str(plaintext)

        return vote


    def vote(self, election_key, voter, plaintext,
                audit_code=None, publish=None):
        """
        Generates and returns an encrypted vote from the encoded plaintext

        :type election_key: dict
        :type voter:
        :type plaintext: int
        :type audit_code:
        :publish: None
        :rtype: dict
        """
        election_key = self._extract_value(election_key)
        encoded_plaintext = self._encode_integer(plaintext)
        ciphertext, randomness = self._encrypt(encoded_plaintext, election_key,
            get_secret=True)

        proof = self._prove_encryption(ciphertext, randomness)

        encrypted = self._set_ciphertext_proof(ciphertext, proof)
        fingerprint = self._make_fingerprint(encrypted)

        vote = self._set_vote(voter, encrypted, fingerprint, audit_code, publish, randomness)
        return vote


    def _extract_vote(self, vote):
        """
        :type vote: dict
        :rtype: dict
        """
        voter = vote['voter']
        encrypted = vote['encrypted']
        fingerprint = hash_encode(vote['fingerprint'])

        audit_code = extract_value(vote, 'audit_code', int)
        voter_secret = extract_value(vote, 'voter_secret', mpz)

        previous = None
        if 'previous' in vote.keys():
            previous = hash_encode(vote['previous'])

        index = extract_value(vote, 'index', int)
        status = extract_value(vote, 'status', str)

        cast = partial(self.GroupElement, modulus=self.__modulus)
        plaintext = extract_value(vote, 'plaintext', cast)

        return voter, encrypted, fingerprint, audit_code,\
            voter_secret, previous, index, status, plaintext


    def validate_submitted_vote(self, vote):
        """
        Checks if the vote's fingerprint is correct, returning the fingerprint
        in this case; otherwise an exception gets raised.

        :type vote: dict
        :rtype: bytes
        """
        _, encrypted, fingerprint, _, _, _, _, _, _ = self._extract_vote(vote)

        if not self._verify_encryption(encrypted):
            e = 'Invalid encryption proof'
            raise InvalidVoteError(e)

        if fingerprint != self._make_fingerprint(encrypted):
            e = 'Invalid fingerprint'
            raise InvalidVoteError(e)

        return fingerprint


    def sign_vote(self, vote, comments, election_key, zeus_keypair, trustees, choices):
        """
        choices (candidates) format example:

            ['Party-A: 0-2, 0', 'Party-A: Candidate-0000',
            'Party-B: generator0-2, 1', 'Party-B: Candidate-0001']

        :type vote: dict
        :type comments:
        :type election_key: dict
        :type zeus_keypair: dict
        :type trustees: list[dict]
        :type choices: list[str]
        :rtype:
        """
        __p, __q, __g = self._parameters()

        election_key = self._extract_value(election_key)

        zeus_private_key, zeus_public_key = self._extract_keypair(zeus_keypair)
        zeus_public_key = self._extract_value(zeus_public_key)

        _, encrypted, fingerprint, _, _, previous, index, status, _ = self._extract_vote(vote)

        alpha, beta, commitment, challenge, response = self._extract_fingerprint_params(encrypted)

        trustees = [self._extract_value(trustee) for trustee in trustees]

        m00 = status if status is not None else 'NONE'
        m01 = '%s%s' % (V_FINGERPRINT, fingerprint)
        m02 = '%s%s' % (V_INDEX, ('%d' % index) if index is not None else 'NONE')
        m03 = '%s%s' % (V_PREVIOUS, (previous,)) 	# '%s%s' % (V_PREVIOUS, previous)
        m04 = '%s%s' % (V_ELECTION, str(election_key))
        m05 = '%s%s' % (V_ZEUS_PUBLIC, str(zeus_public_key))
        m06 = '%s%s' % (V_TRUSTEES, ' '.join(str(_) for _ in trustees))
        m07 = '%s%s' % (V_CANDIDATES, ' % '.join('%s' % _.encode('utf-8') for _ in choices))
        m08 = '%s%s' % (V_MODULUS, str(__p))
        m09 = '%s%s' % (V_ORDER, str(__q))
        m10 = '%s%s' % (V_GENERATOR, str(__g))
        m11 = '%s%s' % (V_ALPHA, str(alpha))
        m12 = '%s%s' % (V_BETA, str(beta))
        m13 = '%s%s' % (V_COMMITMENT, str(commitment))
        m14 = '%s%s' % (V_CHALLENGE, str(challenge))
        m15 = '%s%s' % (V_RESPONSE, str(response))
        m16 = '%s%s' % (V_COMMENTS, (comments,))

        message = '\n'.join((m00, m01, m02, m03, m04, m05, m06, m07,\
            m08, m09, m10, m11, m12, m13, m14, m15, m16))

        signed_message = self.sign_text_message(message, zeus_private_key)
        message, exponent, c_1, c_2 = self._extract_signed_message(signed_message)
        exponent, c_1, c_2 = str(exponent), str(c_1), str(c_2)

        vote_signature = message
        vote_signature += '\n-----------------\n'
        vote_signature += '%s\n%s\n%s\n' % (exponent, c_1, c_2)

        return vote_signature


    def verify_vote_signature(self, vote_signature):
        """
        Returns `True` if the signature is verified, otherwise raises exception

        :type vote_signature: str
        :rtype: bool
        """
        message, _, exponent, c_1, c_2, _ = vote_signature.rsplit('\n', 5)

        (m00, m01, m02, m03, m04, m05, m06, m07, m08, m09,
            m10, m11, m12, m13, m14, m15, m16) = message.split('\n', 16)

        # Check signature structure

        if not ((m00.startswith(V_CAST_VOTE) or
            m00.startswith(V_AUDIT_REQUEST) or
            m00.startswith(V_PUBLIC_AUDIT) or
            m00.startswith(V_PUBLIC_AUDIT_FAILED) or
            m00.startswith('NONE')) or
            not m01.startswith(V_FINGERPRINT) or
            not m02.startswith(V_INDEX) or
            not m03.startswith(V_PREVIOUS) or
            not m04.startswith(V_ELECTION) or
            not m05.startswith(V_ZEUS_PUBLIC) or
            not m06.startswith(V_TRUSTEES) or
            not m07.startswith(V_CANDIDATES) or
            not m08.startswith(V_MODULUS) or
            not m09.startswith(V_ORDER) or
            not m10.startswith(V_GENERATOR) or
            not m11.startswith(V_ALPHA) or
            not m12.startswith(V_BETA) or
            not m13.startswith(V_COMMITMENT) or
            not m14.startswith(V_CHALLENGE) or
            not m15.startswith(V_RESPONSE) or
            not m16.startswith(V_COMMENTS)):
            e = 'Invalid vote signature structure'
            raise InvalidStructureError(e)

        # Extract data

        status = m00
        fingerprint = m01[len(V_FINGERPRINT):]

        index_str = m02[len(V_INDEX):]
        if index_str == 'NONE':
            index = None
        elif index_str.isdigit():
            index = int(index_str)
        else:
            e = "Invalid vote index '%s'" % index_str
            raise InvalidSignatureError(e)

        previous = m03[len(V_PREVIOUS):]

        zeus_public_key = mpz(m05[len(V_ZEUS_PUBLIC):])
        zeus_public_key = self._set_public_key_from_value(zeus_public_key)

        _m06 = m06[len(V_TRUSTEES):]
        trustess = [int(_) for _ in _m06.split(' ')] if _m06 else []

        _m07 = m07[len(V_CANDIDATES):]
        candidates = _m07.split(' % ')

        modulus = mpz(m08[len(V_MODULUS):])
        order = mpz(m09[len(V_ORDER):])
        generator = mpz(m10[len(V_GENERATOR):])

        alpha = ModPrimeElement(mpz(m11[len(V_ALPHA):]), self.__modulus)
        beta = ModPrimeElement(mpz(m11[len(V_BETA):]), self.__modulus)

        commitment = mpz(m11[len(V_COMMITMENT):])
        challenge = mpz(m11[len(V_CHALLENGE):])
        response = mpz(m12[len(V_RESPONSE):])

        comments = m16[len(V_COMMENTS):]

        # Retrieve signed message

        exponent = mpz(exponent)
        c_1 = mpz(c_1)
        c_2 = mpz(c_2)
        signed_message = self._set_signed_message(message,
            signature=self._set_dsa_signature(exponent, c_1, c_2))

        # Validate signature or raise exception otherwise
        if not self.verify_text_signature(signed_message, zeus_public_key):
            e = 'Invalid vote signature'
            raise InvalidSignatureError(e)

        # Verify encryption proof or raise exception otherwise
        ciphertext = self._set_ciphertext(alpha, beta)
        proof = self._set_schnorr_proof(commitment, challenge, response)
        encrypted = self._set_ciphertext_proof(ciphertext, proof)
        # if index is not None and not self._verify_encryption(encrypted):
        if (index is not None and not self._verify_encryption(encrypted)):
            e = 'Invalid vote encryption'
            raise InvalidEncryptionError(e)

        return True


    def verify_audit_votes(self, election_key, choices, votes=None, audit_reqs=None):
        """
        :type election_key: dict
        :type choices:
        :type votes:
        :type audit_reqs:
        :rtype: (list, list)
        """
        missing = []
        failed = []

        add_plaintext = 1
        nr_candidates = len(choices)
        max_encoded = gamma_encoding_max(nr_candidates)

        for vote in votes:
            _, encrypted, _, _, voter_secret, _, _, _, _ = self._extract_vote(vote)

            if not voter_secret:
                missing.append(vote)
                continue
            if not self._verify_encryption(encrypted):
                failed.append(vote)
                continue

            alpha_vote, _, _, _, _ = self._extract_fingerprint_params(encrypted)
            alpha = self.group.generate(voter_secret)

            if alpha != alpha_vote:
                failed.append(vote)
                continue

            encoded = self._decrypt_with_randomness(election_key,
                ciphertext, voter_secret)

            if encoded.value > max_encoded.value:
                failed.append(vote)
            if add_plaintext:
                vote['plaintext'] = encoded.value

        return missing, failed

    # Mixing?

    def _set_factor(self, data, proof):
        """
        :type data: ModPrimeElement
        :type proof: dict
        :rtype: dict
        """
        factor = {'data': data.value, 'proof': proof}
        return factor


    def _extract_factor(self, factor):
        """
        :type factor: dict
        :rtype: tuple
        """
        data = ModPrimeElement(factor['data'], self.__modulus)
        proof = factor['proof']
        return data, proof


    def _set_trustee_factors(self, public, factors):
        """
        :type public:
        :type factors: list[dict]
        :rtype: dict
        """
        trustee_factors = {'public': public, 'factors': factors}
        return trustee_factors


    def _extract_trustee_factors(self, trustee_factors):
        """
        :type trustee_factors:
        :rtype: tuple
        """
        public = trustee_factors['public']
        factors = trustee_factors['factors']
        return public, factors


    def _compute_decryption_factors(self, secret, ciphers):
        """
        Uses the provided `secret` x to construct a DDH tuple for each of the
        provided `ciphers` and generates proof-of-knowledge that the
        constructed tuple is DDH

        Returns a list of these proofs along with the last member of the
        corresponding DDH

        For each ciphertext

        {'alpha': a, 'beta': b}

        from the provided `ciphers`, supposing that

        a = g ^ r (modp)

        as the result of ElGamal-encryption, generate a proof-of-knowledge
        (Schnorr-proof) s that the tuple

                g ^ x (modp), g ^ r (modp), g ^ (x * r) modp

        is DDH and return the list of pairs (s, g ^ (x * r) modp)

        :type secret: mpz
        :type ciphers: list
        :rtype: list
        """
        public = self.group.generate(secret)                        # g ^ x         (mod p)

        factors = []
        append = factors.append
        for cipher in ciphers:

            alpha, _ = self._extract_ciphertext(cipher)             # g ^ r         (mod p)
            data = alpha * secret                                   # g ^ (x * r)   (mod p)

            ddh = (alpha, public, data)

            proof = self._chaum_pedersen_proof(ddh, secret)
            factor = self._set_factor(data, proof)
            append(factor)

        return factors


    def _verify_decryption_factors(self, public, ciphers, factors):
        """
        Returns `True` iff all the provided cipher-factor pairs are
        successfully verified under the provided `public` y

        .. note:: `False` is returned if the number of ciphers is unequal
        to the number of factors

        For each ciphertext

        {'alpha': a, 'beta': ...}

        from the provided `ciphers` and corresponding factor

        {'data': c, 'proof': s}

        from the provided `factors`, the current cipher-factor pair will be
        verified iff the (Shnorr-proof) s proves knowledge that the tuple

        (a, y, c)

        is a DDH

        :type public: ModPrimeElement
        :type ciphers: list
        :type factors: list
        :rtype: bool
        """
        if len(ciphers) != len(factors):
            return False

        for cipher, factor in zip(ciphers, factors):
            alpha, _ = self._extract_ciphertext(cipher)
            data, proof = self._extract_factor(factor)

            ddh = (alpha, public, data)
            if not self._chaum_pedersen_verify(ddh, proof):
                return False

        return True


    def _combine_decryption_factors(self, factors):
        """
        :type factors: list
        :rtype:
        """
        if not factors:
            return 0

        master_factors = []

        # append = master_factors.append
        # for trustees_factor in zip(*factors):
        #     master_factor = self.__group.unit()

        return master_factors



    def compute_zeus_factors(self, mixed_ballots, secret):
        """
        :type mixed_ballots: list
        :type secret: str
        """
        secret = mpz(secret)
        return self._compute_decryption_factors(secret, mixed_ballots)

    def validate_trustee_factors(self, trustee_public, trustee_factors, mixed_ballots):
        """
        If not True, raises Error

        :type trustee_public:
        :type trustee_factors:
        :type mixed_ballots: list
        :rtype: bool
        """
        pass # ---> crypto.py

    def decrypt_ballots(self, mixed_ballots, zeus_factors, trustee_factors):
        pass # -> crypto

    def validate_decrypting(self, mixed_ballots, public_shares, zeus_factors,
            trustees_factors, zeus_public):
        pass # -> crypto.py


    def convert_mixes_to_elements(self, mixes):
        """
        """
        pass # --> elgamal.py


    def convert_mixes(self, mixes):
        """
        """
        pass # --> elgamal.py


    def _get_last_mix(mixes):
        """
        """
        return mixes[-1]


    def _get_mixer_class(self, module):
        """
        :type module: str
        :rtype:
        """
        module_name = importlib.import_module('zeus_crypto.mixnets.%s' % module)
        _cls = getattr(module_name, module.capitalize())
        return _cls


    def initialize_mixer(self, module, params, election_key):
        """
        :type module: str
        :type params: dict
        :type election_key: dict
        """
        public_key = self._extract_value(election_key)	# GroupElement
        _cls = self._get_mixer_class(module)
        return _cls(params, public_key)


    # Key management

    ###############################################################
    #                                                             #
    #    By keypair is meant a dictionary of the form             #
    #                                                             #
    #    {                                                        #
    #        'private': mpz,                                      #
    #        'public': {                                          #
    #            'value': ModPrimeElement,                        #
    #            'proof': ...                                     #
    #        }                                                    #
    #    }                                                        #
    #                                                             #
    #   where tha value for the key `proof` is either `None` or   #
    #   a Schnorr-proof                                           #
    #                                                             #
    ###############################################################


    def _set_public_key_from_element(self, element, proof=None):
        """
        :type element: ModPrimeElement
        :type proof: dict
        :rtype: dict
        """
        public_key = {'value': element, 'proof': proof}
        return public_key


    def _set_public_key_from_value(self, value, proof=None):
        """
        :type value: mpz
        :type proof: dict
        :rtype: dict
        """
        public_key = {
            'value': ModPrimeElement(value, self.__modulus),
            'proof': proof
        }
        return public_key


    def _set_keypair(self, private_key, public_key):
        """
        :type private_key:
        :type public_key: dict
        :rtype: dict
        """
        keypair = {'private': private_key, 'public': public_key}
        return keypair


    def _extract_keypair(self, keypair):
        """
        Returns a tuple with the private and public part of the provided key in
        the form of a numerical value (mpz) and a dict respectively

        :type keypair: dict
        :rtype: tuple
        """
        return keypair['private'], keypair['public']


    def _extract_private(self, keypair):
        """
        :type keypair: dict
        :rtype: mpz
        """
        return keypair['private']


    def _extract_public(self, keypair):
        """
        :type: keypair
        :rtype: dict
        """
        return keypair['public']


    def _extract_public_value(self, keypair):
        """
        :type keypair: dict
        :rtype: ModPrimeElement
        """
        return keypair['public']['value']


    def _extract_value(self, public_key):
        """
        :type public_key: dict or ModPrimeElement
        :rtype: ModPrimeElement
        """
        return public_key['value'] if type(public_key) is dict else public_key


    def _combine_public_keys(self, initial, public_keys):
        """
        Assuming the provided public keys in the form of gorup elements,
        computes and returns the combined key

        :type initial: ModPrimeElement
        :type public_keys: list[ModPrimeElement]
        :rtype: ModPrimeElement
        """
        combined = initial
        for public_key in public_keys:
            combined = combined * public_key
        return combined


    def keygen(self, private_key=None, schnorr=True):
        """
        Generates and returns a keypair. If `shnorr` is `True`, the public part
        will also contain a proof-of-knowledge of the private part.

        :type private_key: mpz
        :type schnorr: bool
        :rtype: dict
        """

        __group = self.__group

        if private_key is None:
            private_key = __group.random_exponent(min=3)

        elif not 1 < private_key < self.__order:
            e = 'Provided private key exceeds the allowed range'
            raise InvalidKeyError(e)

        public_key = __group.generate(private_key)              # y = g ^ x modp

        proof = None
        if schnorr is True:
            proof = self._schnorr_proof(private_key, public_key)

        public_key = self._set_public_key_from_element(public_key, proof)
        keypair = self._set_keypair(private_key, public_key)

        return keypair


    def validate_public_key(self, public_key):
        """
        Assuming `public_key` to be the public part

        {
            'value': ModPrimeElement,
            'proof': ...
        }

        of a keypair, verifies the included proof-of-knowledge of its private counterpart

        :type public_key: dict
        :rtype: bool
        """
        try:
            proof = public_key['proof']
        except KeyError:
            # No proof has been provided together with the public key
            return False

        public_key = public_key['value']

        if not public_key.contained_in(self.__group):
            return False

        return self._schnorr_verify(proof=proof, public=public_key)


    def extract_value(self, public_key):
        """
        Returns as common integer the value of the provided public key

        :rtype: int
        """
        return int(public_key['value'].value)


    # Text-message signatures

    #####################################################################
    #                                                                   #
    #    By signed message is meant a dictionary of the form            #
    #                                                                   #
    #    {                                                              #
    #        'message': str,                                            #
    #        'signature': {                                             #
    #            'exponent': mpz,                                       #
    #            'commitments': {                                       #
    #               'c_1': mpz,                                         #
    #               'c_2': mpz                                          #
    #        }                                                          #
    #    }                                                              #
    #                                                                   #
    #####################################################################


    def _set_signed_message(self, message, signature):
        """
        :type message: str
        :type signature: dict
        :rtype: dict
        """
        return {'message': message, 'signature': signature}


    def _extract_message_signature(self, signed_message):
        """
        :type signed_message: dict
        :rtype: tuple
        """
        message = signed_message['message']
        signature = signed_message['signature']
        return message, signature


    def _extract_signed_message(self, signed_message):
        """
        :type signed_message: dict
        :rtype: tuple
        """
        message = signed_message['message']
        signature = signed_message['signature']
        exponent, c_1, c_2 = self._extract_dsa_signature(signature)
        return message, exponent, c_1, c_2


    def sign_text_message(self, message, private_key):
        """
        Signs the provided `message` m with the provided `private_key` x,
        returning the signed message

        {
            'message': m,
            'signature': {
                'exponent': H(m),
                'commitments': {
                    'c_1': (g ^ r modp) modq,
                    'c_2': (H(m) + x * c_1)/r modq
                }
            }
        }

        for a once used randomness 1 < r < q.

        NOTE: The original message m gets hashed as H(m) before being signed for
        defence against existential forgery.

        :type message: str
        :type private_key: mpz
        :rtype: dict
        """

        hashed_message = self.__group.exponent_from_texts(message)
        signature = self._dsa_signature(hashed_message, private_key)

        signed_message = self._set_signed_message(message, signature)
        return signed_message


    def verify_text_signature(self, signed_message, public_key):
        """
        Given a signed message `signed_message`, verifies the attached signature
        under the provided public key `public_key`

        :type signed_message: dict
        :type public_key: dict
        :rtype: bool
        """

        # Extract data from signed message
        message, signature = self._extract_message_signature(signed_message)

        # Extract value of public key
        public_key = self._extract_value(public_key)

        # Verify signature
        hashed_message = self.__group.exponent_from_texts(message)              # H(m)
        verified = self._dsa_verify(hashed_message, signature, public_key)

        return verified


    # Digital Signature Algorithm

    ############################################################
    #                                                          #
    #    By DSA-signature is meant a dictionary of the form    #
    #                                                          #
    # 	{                                                      #
    #       'exponent': mpz,                                   #
    #       'commitments': {                                   #
    #           'c_1': mpz,                                    #
    #           'c_2': mpz                                     #
    #       }                                                  #
    # 	}                                                      #
    #                                                          #
    ############################################################


    def _set_dsa_signature(self, exponent, c_1, c_2):
        """
        :exponent: mpz
        :type c_1: mpz
        :type c_2: mpz
        :rtype: dict
        """
        signature = {
            'exponent': exponent,
            'commitments': {
                'c_1': c_1,
                'c_2': c_2
            }
        }

        return signature


    def _extract_dsa_signature(self, signature):
        """
        :type signature: dict
        :rtype: tuple
        """
        exponent = signature['exponent']
        commitments = signature['commitments']
        c_1 = commitments['c_1']
        c_2 = commitments['c_2']
        return exponent, c_1, c_2


    def _dsa_signature(self, exponent, private_key):
        """
        Returns and computes the DSA-signature

        {
            'exponent': e,
            'commitments': {
                'c_1': (g ^ r modp) modq
                'c_2': (e + x * c_1)/r modq
            }
        }

        of the provided `exponent` e (assumed to be in the range {1, ..., q - 1})
        under the `private_key` x for a once used randmoness 1 < r < q

        :type exponent: mpz
        :type private_key: mpz
        :rtype: dict
        """
        __group = self.__group
        __q = self.__order

        randomness = __group.random_exponent()                           # 1 < r < q
        c_1 = f_mod(__group.generate(randomness).value, __q)             # (g ^ r modp) modq

        exps = __group.add_exponents(exponent, mul(private_key, c_1))    # (e + x * c_1) modq
        r_inv = invert(randomness, __q)                                  # r ^ -1 modq
        c_2 = f_mod(mul(exps, r_inv), __q)                               # (e + x * c_1)/r modq

        signature = self._set_dsa_signature(exponent, c_1, c_2)
        return signature


    def _dsa_verify(self, exponent, signature, public_key):
        """
        Verifies that the provided DSA-signature `signature` signs the given
        `exponent` under the given `public_key`

        :type exponent: mpz
        :type signature: dict
        :type public_key: ModPrimeElement
        :rtype: bool
        """
        __group = self.__group
        __q = self.__order

        # Extract data from signature
        _, c_1, c_2 = self._extract_dsa_signature(signature)

        # Commitments' validity check
        for c in (c_1, c_2):
            if not 0 < c < __q:
                return False

        # Proceed to signature validation

        c_2_inv = invert(c_2, __q)                                      # c_2 ^ -1 modq

        v_1 = f_mod(mul(exponent, c_2_inv), __q)                        # (e + c_2 ^ -1) modq
        v_2 = f_mod(mul(c_1, c_2_inv), __q)                             # (v_1 * c_2 ^ -1) modq

        element = (__group.generate(v_1) * public_key ** v_2).value     # (g ^ v_1 * y ^ v_2) modp

        # ((g ^ v_1 * y ^ v_2) modp) modq == c_1 ?
        return f_mod(element, __q) == c_1


    # Schnorr protocol

    ############################################################
    #                                                          #
    #    By Schnorr-proof is meant a dictionary of the form    #
    #                                                          #
    #    {                                                     #
    #       'commitment': ModPrimeElement                      #
    #       'challenge': mpz                                   #
    #       'response': mpz                                    #
    #    }                                                     #
    #                                                          #
    ############################################################


    def _set_schnorr_proof(self, commitment, challenge, response):
        """
        :type commitment: ModPrimeElement
        :type challenge: mpz
        :type response: mpz
        :rtype: dict
        """
        proof = {
            'commitment': commitment,
            'challenge': challenge,
            'response': response
        }

        return proof

    def _extract_schnorr_proof(self, proof):
        """
        :type proof: dict
        :rtype: tuple
        """
        commitment = proof['commitment']
        challenge = proof['challenge']
        response = proof['response']

        return commitment, challenge, response


    def _schnorr_proof(self, secret, public, *extras):
        """
        Implementation of Schnorr protocol from the prover's side (non-interactive)

        Returns proof-of-knowldge (Schnorr-proof) of the discrete logarithm x (`secret`)
        of y (`public`), with `*extras` being used in the Fiat-Shamir heuristic

        :type secret: mpz
        :type public: modPrimeElement
        :type *extras: mpz or int or ModPrimeElement
        :rtype: dict
        """

        __group = self.__group

        randomness = __group.random_exponent()          # r
        commitment = __group.generate(randomness)       # g ^ r

        challenge  = __group.fiatshamir(
            public,
            commitment,
            *extras)     # c = g ^ ( H( p | g | q | y | g ^ r | extras ) modq ) modp

        response = __group.add_exponents(randomness, challenge * secret) # r + c * x

        proof = self._set_schnorr_proof(commitment, challenge, response)
        return proof


    def _schnorr_verify(self, proof, public, *extras):
        """
        Implementation of Schnorr protocol from the verifier's side (non-interactive)

        Validates the demonstrated (Schnorr) proof-of-knowledge `proof` of the discrete
        logarithm of y (`public`), with `*extras` assumed to have been used in the
        Fiat-Shamir heuristic

        :type proof: dict
        :type public: modPrimeElement
        :type *extras: mpz or int or ModPrimeElement
        """
        __group = self.__group

        # g ^ r, c, s
        commitment, challenge, response = self._extract_schnorr_proof(proof)

        # Check correctness of chalenge:
        # c == g ^ ( H( p | g | q | y | g ^ r | extras ) modq ) modp ?
        _challenge = __group.fiatshamir(
            public,
            commitment,
            *extras)

        if _challenge != challenge:
            return False

        # g ^ s modp == (g ^ r) * (y ^ c) modp ?
        return __group.generate(response) == commitment * (public ** challenge)


    # Chaum-Pedersen protocol

    ###################################################################
    #                                                                 #
    #    By Chaum-Pedersen proof is meant a dictionary of the form    #
    #                                                                 #
    #    {                                                            #
    #        'base_commitment': ModPrimeElement                       #
    #        'message_commitment': ModPrimeElement                    #
    #        'challenge': mpz                                         #
    #        'response': mpz                                          #
    #    }                                                            #
    #                                                                 #
    ###################################################################


    def _set_chaum_pedersen_proof(self, base_commitment, message_commitment,
        challenge, response):
        """
        :type base_commitment: ModPrimeElement
        :type message_commitment: ModPrimeElement
        :challenge: mpz
        :response: mpz
        :rtype: dict
        """
        proof = {
            'base_commitment': base_commitment,
            'message_commitment': message_commitment,
            'challenge': challenge,
            'response': response
        }

        return proof

    def _extract_chaum_pedersen_proof(self, proof):
        """
        :type proof: dict
        :rtype: tuple
        """
        base_commitment = proof['base_commitment']
        message_commitment = proof['message_commitment']
        challenge = proof['challenge']
        response = proof['response']

        return base_commitment, message_commitment, challenge, response


    def _chaum_pedersen_proof(self, ddh, z):
        """
        Implementation of Chaum-Pedersen protocol from the prover's side (non-interactive)

        Returns zero-knowledge proof (Chaum-Pedersen proof) that the provided 3-ple `ddh`
        is a DDH with respect to the generator g of the cryptosystem's underlying group,
        i.e., of the form

                        (g ^ x modp, g ^ z modp, g ^ (x * z) modp)

        for some integers 0 <= x, z < q

        The provided `ddh` is of the form

                    [ModPrimeElement, ModPrimeElement, ModPrimeElement]

        :type ddh: list
        :type z: mpz
        :rtype: dict
        """

        __group = self.__group

        u, v, w = ddh

        randomness = __group.random_exponent()

        g_commitment = __group.generate(randomness)                     # g ^ r
        u_commitment = u ** randomness                                  # u ^ r

        challenge = __group.fiatshamir(
            u, v, w,
            g_commitment,
            u_commitment)   # c = g ^ ( H( p | g | q | u | v | w | g ^ r | u ^ r ) modq ) modp

        response = __group.add_exponents(randomness, challenge * z)     # s = r + c * z  modq

        proof = self._set_chaum_pedersen_proof(g_commitment, u_commitment, challenge, response)
        return proof


    def _chaum_pedersen_verify(self, ddh, proof):
        """
        Implementation of Chaum-Pedersen protocol from the verifier's side (non-interactive)

        Verifies that the demonstrated `proof` proves knowledge that the provided 3-ple `ddh`
        is a DDH with respect to the generator g of the systemtem's underlying group, i.e., of
        the form

                                (u, v, g ^ (x * z) modp)


        where u = g ^ x (modp), v = g ^ z (modp) with 0 <= x, z < q

        The provided `ddh` is of the form

                    (ModPrimeElement, ModPrimeElement, ModPrimeElement)

        and the provided `proof` of the form

        {
            'base_commitment': ModPrimeElement
            'message_commitment': ModPrimeElement
            'challenge': mpz
            'response': mpz
        }

        :type ddh: list
        :type proof: dict
        :rtype: bool
        """

        __group = self.__group

        u, v, w = ddh

        # g ^ r, u ^ r, c, s
        g_commitment, u_commitment, challenge, response =\
            self._extract_chaum_pedersen_proof(proof)

        # Check correctness of challenge:
        # c == g ^ ( H( p | g | q | u | v | w | g ^ r | u ^ r ) modq ) modp ?
        _challenge = __group.fiatshamir(
            u, v, w,
            g_commitment,
            u_commitment)

        if _challenge != challenge:
            return False

        # Verify prover's commitment to presumed randomness:
        # g ^ s == g ^ r * v ^ c  modp ?
        if __group.generate(response) != g_commitment * (v ** challenge):
            return False

        # Verify that the provided u is of the form g ^ (k * z) for some k (and
        # thus k = x due to prover's commitment to randomness r):
        # u ^ s == u ^ r * w ^ c  modp ?
        return u ** response == u_commitment * (w ** challenge)


    # El-Gamal encryption and decryption

    ################################################################
    #                                                              #
    #    By ElGamal-cipertext is meant a dictionary of the form    #
    #                                                              #
    #    {                                                         #
    #        'alpha': ModPrimeElement                              #
    #        'beta': ModPrimeElement                               #
    #    }                                                         #
    #                                                              #
    ################################################################


    def _set_ciphertext(self, alpha, beta):
        """
        :type alpha: ModPrimeElement
        :type beta: ModPrimeElement
        :rtype: dict
        """
        return {'alpha': alpha, 'beta': beta}


    def _extract_ciphertext(self, ciphertext):
        """
        :type ciphertext: dict
        :rtype: typle
        """
        alpha = ciphertext['alpha']
        beta = ciphertext['beta']
        return alpha, beta


    def _set_ciphertext_proof(self, ciphertext, proof):
        """
        :type ciphertext: dict
        :type proof: dict
        :rtype: dict
        """
        return {'ciphertext': ciphertext, 'proof': proof}


    def _extract_ciphertext_proof(self, ciphertext_proof):
        """
        :type ciphertext_proof: dict
        :rtype: tuple
        """
        ciphertext = ciphertext_proof['ciphertext']
        proof = ciphertext_proof['proof']
        return ciphertext, proof


    def _extract_fingerprint_params(self, ciphertext_proof):
        """
        :type ciphertext_proof: dict
        :rtype: tuple
        """
        ciphertext, proof = self._extract_ciphertext_proof(ciphertext_proof)
        alpha, beta = self._extract_ciphertext(ciphertext)
        commitment, challenge, response = self._extract_schnorr_proof(proof)
        return alpha, beta, commitment, challenge, response


    def _make_fingerprint(self, ciphertext_proof):
        """
        :type ciphertext_proof: dict
        :rtype: bytes
        """
        fingerprint_params = self._extract_fingerprint_params(ciphertext_proof)
        fingerprint = hash_texts(*[str(param) for param in fingerprint_params])
        return fingerprint


    def _encrypt(self, element, public_key, randomness=None, get_secret=False):
        """
        ElGamal encryption

        Computes and returns the ElGamal-ciphertext

        {
            'alpha': g ^ r (modp)
            'beta': m * y ^ r (mod p)
        }

        of the provided `element` m, where `public_key` is the receiver's
        public key y and 1 < r < q a once used randomness

        :type element: ModPrimeElement
        :type public_key: ModPrimeElement
        :type randomness: mpz
        :type get_secret: bool
        :rtype: dict
        """
        __group = self.__group

        if randomness is None:
            randomness = __group.random_exponent()

        alpha = __group.generate(randomness)            # g ^ r (modp)
        beta = element * public_key ** randomness       # m * y ^ r (modp)

        ciphertext = self._set_ciphertext(alpha, beta)

        if get_secret:
            return ciphertext, randomness
        return ciphertext


    def reencrypt(self, ciphertext, public_key, randomness=None, get_secret=False):
        """
        Re-encryption of ElGamal-ciphertexts

        Given the ElGamal-ciphertext `ciphertext`

        {'alpha': a, 'beta': b}

        and an element `public_key` y, computes and returns the ElGamal-ciphertext

        {
            'alpha': a * g ^ r      (modp)
            'beta': b * y ^ r       (modp)
        }

        .. note:: (Special case of same public key) Given the ElGamal encryption

        {
            'alpha': g ^ r_0        (modp)
            'beta': m * y ^ r_0     (modp)
        }

        of an original message m under the public key y, re-encrypting n times under
        the same key y and successive randomnesses r_1, ..., r_n yields

        {
            'alpha': g ^ (r_0 + r_1 + ... + r_n)        (modp)
            'beta': m * y ^ (r_0 + r_1 + ... + r_n)     (modp)
        }

        i.e., is equivalent to encrypting once with randomness r_0 + r_1 + ... + r_n

        :type ciphertext: dict
        :type public_key: ModPrimeElement
        :type randomness: mpz
        :type get_secret: bool
        :rtype: dict or tuple
        """
        __group = self.__group

        if randomness is None:
            randomness = __group.random_exponent(min=3)

        alpha, beta = self._extract_ciphertext(ciphertext)

        alpha = alpha * __group.generate(randomness)                # a * g ^ r
        beta = beta * public_key ** randomness                      # b * y ^ r

        ciphertext = self._set_ciphertext(alpha, beta)

        if get_secret:
            return ciphertext, randomness
        return ciphertext


    def _prove_encryption(self, ciphertext, randomness, proof_method=None):
        """
        Generates according to the provided (zero-knowledge) `proof_method` a
        proof-of-knowledge of the `randomness` r involved in the encryption
        yielding the given ElGamal-ciphertext `ciphertext`

        If no proof-method is provided, then Schnorr-proof is applied by default

        :type ciphertext: dict
        :type randomness: mpz
        :type proof_method: function
        :rtype: dict
        """
        alpha, beta = self._extract_ciphertext(ciphertext)

        if proof_method is None:
            proof_method = self._schnorr_proof
        proof = proof_method(randomness, alpha, beta)

        return proof


    def _verify_encryption(self, ciphertext_proof, verification_method=None):
        """
        Verifies proof-of-knowledge of the  randomness used in
        the encryption yielding the provided ElGamal-ciphertext

        :type ciphertext_proof: dict
        :rtype: bool
        """
        ciphertext, proof = self._extract_ciphertext_proof(ciphertext_proof)
        alpha, beta = self._extract_ciphertext(ciphertext)

        if verification_method is None:
            verification_method = self._schnorr_verify

        verified = verification_method(proof, alpha, beta)

        return verified


    def _decrypt(self, ciphertext, private_key):
        """
        Standard ElGamal decryption

        Decrypts the provided ElGamal-ciphertext `ciphertext`

        {'alpha': a, 'beta': b}

        under the provided `private_key` x, returning the original element

        (a ^ x) ^ -1 * b

        :type ciphertext: dict
        :type private_key: mpz
        :rtype: ModPrimeElement

        .. note:: this function is not used by zeus; it is here included
        for completeness of the cryptossytem and testing purposes
        """
        alpha, beta = self._extract_ciphertext(ciphertext)

        original = (alpha ** private_key).inverse * beta        # (alpha ^ x) ^ -1 * beta (modp)

        return original


    def _decrypt_with_decryptor(self, ciphertext, decryptor):
        """
        Given the El-Gamal-ciphertext `ciphertext`

        {'alpha': a, 'beta': b}

        and `decryptor` d, computes and returns the element

        d ^ -1 * b

        :type ciphertext: dict
        :type decryptor: ModPrimeElement
        :rtype: ModPrimeElement

        .. note:: specializes to standard ElGamal decryption if the decryptor
        is chosen to be a ^ x, where x is the private key used at ecnryption
        """
        _, beta = self._extract_ciphertext(ciphertext)

        decryptor = decryptor.inverse                           # decryptor ^ -1 * beta (modp)
        encoded = decryptor * beta

        return encoded


    def _decrypt_with_randomness(self, ciphertext, public, secret):
        """
        Given the ElGamal-ciphertext `ciphertext`

        {'alpha': a, 'beta': b},

        a group element `public` y and an exponent `secret` x, computes and
        returns the element

        (y ^ x) ^ -1 * b - 1 (mod p)

        if (y ^ x) ^ -1 * b happens to be contained in the cryptosystem's
        underlying group; otherwise the element

        (-(y ^ x) ^ -1 * b (mod p)) - 1 (mod p)

        is returned

        :type public: ModPrimeElement
        :type ciphertext: dict
        :type secret: mpz
        :rtype: ModPrimeElement
        """
        _, beta = self._extract_ciphertext(ciphertext)

        encoded = (public ** secret).inverse * beta             # (y ^ x) ^ -1 * beta (modp)

        decoded = self.group.decode_with_randomness(encoded)
        return decoded
