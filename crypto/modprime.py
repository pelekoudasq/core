import Crypto
from Crypto.Util.number import isPrime
from gmpy2 import mpz, mpq, powmod, invert, mul, add, f_mod, qdiv

from .elgamal import ElGamalCrypto
from .algebra import Group, GroupElement
from .exceptions import AlgebraError, WrongCryptoError, WeakCryptoError
from .utils import int_from_bytes, hash_nums, hash_texts, random_integer


class ModPrimeElement(GroupElement):
    """
    Element of the multiplicative group Z*_p = Z_p - {0}, p > 2 prime
    """

    __slots__ = ('__value', '__modulus', '__inverse')

    def __init__(self, value, modulus):
        """
        Element of the multiplicative group Z*_p = Z_p - {0}, p > 2 prime

        :type value: mpz
        :type modulus: mpz
        """
        self.__value = value
        self.__modulus = modulus

        # Set here modular inverse (costly to compute everytime)
        self.__inverse = invert(self.__value, self.__modulus)

    @property
    def value(self):
        """
        :rtype: mpz
        """
        return self.__value

    @property
    def modulus(self):
        """
        :rtype: mpz
        """
        return self.__modulus

    @property
    def inverse(self):
        """
        :rtype: ModPrimeElement
        """
        return self.__class__(value=self.__inverse, modulus=self.__modulus)

    @property
    def bit_length(self):
        """
        :rtype: int
        """
        return self.__value.bit_length()

    def __repr__(self):
        """
        :rtype: str
        """
        return str(self.__value)

    def __hash__(self):
        """
        :rtype: int
        """
        return hash(repr(self))

    def __eq__(self, other):
        """
        :type other: ModPrimeElement or mpz
        """
        if isinstance(other, self.__class__):
            return self.__value == other.value
        else:
            return self.value == other

    def __mul__(self, other):
        """
        :type other: ModPrimeElement
        """
        result = self.__value * other.value % self.__modulus
        return self.__class__(value=result, modulus=self.__modulus)

    def __pow__(self, exp):
        """
        :type exp: mpz
        :rtype: ModPrimeElement
        """
        # # result = self.__value ** exp % self.__modulus ---> "...outrageous exponent"
        # Use gmpy2.powmod instead in order to avoid overflow in mpz type
        result = powmod(self.__value, exp, self.__modulus)
        return self.__class__(value=result, modulus=self.__modulus)

    def contained_in(self, group):
        """
        :type: ModPrimeSubgroup
        :rtype: bool
        """
        if isinstance(group, ModPrimeSubgroup) and group.modulus == self.__modulus:
            # Algebraic fact: given the q-subgroup C of Z*_p, p > 2 prime,
            # a mod p element x is contained in C iff x ^ q = 1
            return self ** group.order == 1
        return False


class ModPrimeSubgroup(Group):
    """
    Subgroup of the multiplicative group Z*_p = Z_p - {0}, p > 2 prime

    There is one such group of order q for each divisor 0 < q < p - 1 of p - 1
    and is generated by the r-power, r = (p - 1)/q, of any primitive in Z*_p

    E.g., the default value r = 2 yields the group of quadratic residues modp
    """

    __slots__ = ('__modulus', '__order', '__generator')

    def __init__(self, modulus, root_order=2):
        """
        :type modulus: mpz
        :type root_order: mpz
        """
        modulus = modulus
        root_order = root_order

        if modulus <= 2 or not isPrime(modulus):
            e = 'Provided modulus is not an odd prime'
            raise AlgebraError(e)

        if root_order <= 0 or root_order >= modulus:
            e = 'Provided order of unit-root is not in the allowed range'
            raise AlgebraError(e)

        order, s = divmod(modulus - 1, root_order)

        if s != 0:
            e = 'Provided order of unit-root does not divide the multiplicative group\'s order'
            raise AlgebraError(e)

        self.__modulus = modulus
        self.__order = order

    def __repr__(self):
        """
        :rtype: str
        """
        return '%s (%d, %d)' % (self.__class__, self.__modulus, self.__order)

    def __hash__(self):
        """
        :rtype: str
        """
        return hash(repr(self))

    @property
    def modulus(self):
        """
        :rtype: mpz
        """
        return self.__modulus

    @property
    def order(self):
        """
        :rtype: mpz
        """
        return self.__order

    @property
    def generator(self):
        """
        :rtype: ModPrimeElement
        """
        try:
            return self.__generator
        except AttributeError:
            e = 'No generator has yet been specified for this group'
            raise AlgebraError(e)

    def set_generator(self, element):
        """
        :type element: ModPrimeElement
        """
        self.__generator = element

    def generate(self, exponent):
        """
        :type exponent: mpz
        :rtype: ModPrimeElement
        """
        return self.__generator ** exponent

    def add_exponents(self, *args):
        """
        :type *args: mpz
        :rtype: mpz
        """
        return sum(args) % self.__order

    def random_exponent(self, min=2):
        """
        Returns a random exponent >= `min`, bounded by the group's order

        :rtype: mpz
        """
        # Note: the default value min=2 guarantees that raising the generator
        # to the random exponent r does not yield the generator itself or the
        # group's neutral element (provided that the group's order is > 2)
        exponent = random_integer(min, self.__order)
        return mpz(exponent)

    def random_element(self):
        """
        :rtype: ModPrimeElement
        """
        random_exp = self.random_exponent()
        return self.__generator ** random_exp

    def exponent_from_texts(self, *texts):
        """
        :type *texts: str
        :rtype: mpz
        """
        p = self.__modulus
        q = self.__order
        g = self.__generator.value

        hashed_params = hash_nums(p, q, g).hex()
        hashed_texts = hash_texts(hashed_params, *texts)
        exponent = int_from_bytes(hashed_texts)
        exponent = f_mod(exponent, self.__order)
        return exponent

    def element_from_texts(self, *texts):
        """
        :type *texts: str
        :rtype: ModPrimeElement
        """
        exp = self.exponent_from_texts(*texts)
        return self.generate(exp)

    def fiatshamir(self, *elements):
        """
        The output of this method is only involved in exponent operations

        :type: mpz or ModePrimeElement
        :rtype: mpz
        """

        p = self.__modulus
        q = self.__order
        g = self.__generator.value

        # Convert to mpz if ModPrimeElement
        elements = [x.value if isinstance(x, ModPrimeElement) else x for x in elements]

        digest = hash_nums(p, q, g, *elements)
        reduced = int_from_bytes(digest)
        output = self.generate(reduced).value

        return output       # g ^ ( H( p | g | q | elements)  modq )  modp

    def contains(self, element):
        """
        :type element: modPrimeElement
        :rtype: bool
        """
        if isinstance(element, ModPrimeElement) and element.modulus == self.__modulus:
            # Algebraic fact: given the q-subgroup C of Z*_p, p > 2 prime,
            # an mod p element x is contained in C iff x ^ q = 1
            return element ** self.__order == 1
        return False


class ModPrimeCrypto(ElGamalCrypto):
    """
    ElGamal cryptosystem over the group of r-residues mod p, p > 2 prime.
    Defaults to r = 2, yielding the group of quadratic residues mod p
    """

    MIN_MOD_SIZE = 2048
    MIN_GEN_SIZE = 2000

    GroupElement = ModPrimeElement
    Group = ModPrimeSubgroup

    __slots__ = ('__group')


    def __init__(self, modulus, primitive, root_order=2,
                 check_3mod4=True, prime_order=True, min_mod_size=None, min_gen_size=None):
        """
        Assumes that the provided `primitive` g0 is indeed a primitive mod p (i.e., generates
        the multiplicative group Z*_p) or, equivalently, it is a primitive (p - 1)-root of 1
        (i.e., g0 ^ (p - 1) = 1 and g0 ^ k != 1 for all 0 < k < p - 1)

        :type modulus: int
        :type primitive: int
        :type root_order: int
        :type check_3mod4: bool
        :type prime_order: bool
        :type min_mod_size: int
        :type min_gen_size: int
        """

        # super().__init__(self.__class__, config, *opts)

        # Type conversion

        modulus = mpz(modulus)                                   # p
        primitive = ModPrimeElement(mpz(primitive), modulus)     # g0
        root_order = mpz(root_order)                             # r

        # Resolve group

        try:
            group = ModPrimeSubgroup(modulus, root_order)
        except AlgebraError:
            raise

        self.__group = group

        # Resolve generator

        # Algebraic fact: given a primitive g0 of Z*_p, p > 2 smooth, and 1 < r < p - 1
        # with r | p - 1, then g0 ^ r generates the q-subgroup of Z*_p, q = (p - 1)/r
        generator = primitive ** root_order

        try:
            self.__group.set_generator(generator)
        except AlgebraError:
            raise

        # System validation

        if check_3mod4 and modulus % 4 != 3:
            e = 'Provided modulus is not 3 mod 4'
            raise WrongCryptoError(e)

        if prime_order and not isPrime(group.order):
            e = 'Order of the requested group is not prime'
            raise WrongCryptoError(e)

        MIN_MOD_SIZE = min_mod_size or self.__class__.MIN_MOD_SIZE
        MIN_GEN_SIZE = min_gen_size or self.__class__.MIN_GEN_SIZE

        if modulus.bit_length() < MIN_MOD_SIZE:
            e = 'Provided modulus is < %d bits long' % MIN_MOD_SIZE
            raise WeakCryptoError(e)

        if self.__group.generator.bit_length < MIN_GEN_SIZE:
            e = 'Generator is < %d bits long' % MIN_GEN_SIZE
            raise WeakCryptoError(e)


# -------------------------------- External API --------------------------------

    # Access

    @property
    def system(self):
        """
        :rtype: dict
        """
        __group = self.__group

        p = int(__group.modulus)
        q = int(__group.order)
        g = int(__group.generator.value)

        return {'modulus': p, 'order': q, 'generator': g}


    @property
    def group(self):
        """
        :rtype: ModPrimeSubgroup
        """
        return self.__group


    def get_as_integer(self, public_key):
        """
        Returns the numerical value of the provided public key, assuming a
        dictionary of the form

        {
            'value: ModPrimeElement,
            'proof: ...
        }

        :type public_key: dict
        :rtype: int
        """
        return int(public_key['value'].value)


    # Key generation and validation

    def keygen(self, private_key=None, schnorr=True):
        """
        Generates a keypair of the form

        {
            'private': mpz,
            'public': {
                'value': ModPrimeElement,
                'proof': {
                    'commitment': ModPrimeElement
                    'challenge': mpz
                    'response': mpz
                }
            }
        }

        :type private_key: mpz
        :type schnorr: bool
        :rtype: dict
        """

        __group = self.__group

        key = dict()

        if private_key is None:
            private_key = __group.random_exponent()             # 1 < x < q

        elif not 1 < private_key < __group.order:
            e = 'Provided private key exceeds the allowed range'
            raise InvalidKeyError(e)

        key.update({'private': private_key})

        public_key = __group.generate(private_key)              # y = g ^ x modp
        public = dict({'value': public_key})

        if schnorr is True:
            proof = self._schnorr_proof(private_key, public_key)
            public.update({'proof': proof})

        key.update({'public': public})
        return key


    def validate_key(self, public_key):
        """
        Accepts a dictionary of the form

        {
            'value': ModPrimeElement,
            'proof': {
                'commitment': ModPrimeElement,
                'challenge': mpz,
                'response': mpz
            }
        }

        :type public_key: dict
        :rtype: bool
        """
        try:
            proof = public_key['proof']
        except KeyError:
            # No proof has been provided together with the public key
            return False

        public_key = public_key['value']

        if not public_key.contained_in(self.__group):
            return False

        return self._schnorr_verify(proof=proof, public=public_key)


    # Text-message signatures

    def sign_text_message(self, message, private_key):
        """
        Signs the provided `message` m with the provided `private_key` x under
        the DSA Scheme. Returned signed message is of the form

        {
            'message': str,                 (m)
            'signature': {
                'c_1': ModPrimeElement      ((g ^ r modp) modq)
                'c_2': mpz                  ((H(m) + x * c_1)/r modq)
            }
        }

        for a once used randomness in the range {2, ..., q - 1}. The original
        message m gets hashed as H(m) before being signed for defence against
        existential forgery.

        :type message: str
        :type private_key: mpz
        :rtype: dict
        """

        hashed_message = self.__group.exponent_from_texts(message)
        signature = self._dsa_signature(hashed_message, private_key)

        signed_message = {
            'message': message, 'signature': signature
        }

        return signed_message


    # Encryption/Decryption

    # Elections API

    def verify_text_signature(self, signed_message, public_key):
        """
        Provided signed message is of the form

        {
            'message': str,                 (m)
            'signature': {
                'c_1': ModPrimeElement      ((g ^ r modp) modq)
                'c_2': mpq                  ((H(m) + x * c_1)/r modq)
            }
        }

        and provided public key is assumed to come in the form

        {
            'value': ModPrimeElement,       (y)
            'proof': ...
        }

        Note: the attached proof-of-knowledge is irrelevant to the current
        verification. It exists here only because the current method is a
        high-level functionality and public keys are not separated from
        their corresponding proofs at the high level

        :type signed_message: dict
        :type public_key: dict
        :rtype: bool
        """

        # Extract data from public key
        public_key = public_key['value']

        # Extract data from signed message

        message = signed_message['message']                                     # m
        signature = signed_message['signature']

        # Verify signature

        hashed_message = self.__group.exponent_from_texts(message)              # H(m)
        verified = self._dsa_verify(hashed_message, signature, public_key)

        return verified

    #TODO: implement
    def sign_vote(self, vote, comments, election_public, zeus_key, trustees, choices):
        """
        :type vote:
        :type comments:
        :type election_public:
        :type zeus_key:
        :type trustees:
        :type choices:
        :rtype:
        """
        pass

    #TODO: implement
    def verify_vote_signature(self, vote_signature):
        """
        :type vote_signature:
        :rtype: bool
        """
        pass

    #TODO: implement
    def verify_audit_votes(self, election_public, choices, votes=None, audit_reqs=None):
        """
        :type election_public:
        :type choices:
        :type votes:
        :type audit_reqs:
        """
        pass

# -------------------------------- Internal API --------------------------------

    # Access

    def _get_as_element(self, public_key):
        """
        Assumes a dictionary of the form

        {
            'value: ModPrimeElement,
            'proof: ...
        }

        :type public_key: dict
        :rtype: ModPrimeElement
        """
        return public_key['value']


    # Schnorr protocol

    def _schnorr_proof(self, secret, public, *extras):
        """
        Implementation of Schnorr protocol from the prover's side (non-interactive)

        Returns proof-of-knowldge of the discrete logarithm x (`secret`) of y (`public`).
        `*extras` are to be used in the Fiat-Shamir heuristic. The proof has the form

        {
            'commitment': ModPrimeElement
            'challenge': mpz
            'response': mpz
        }

        :type secret: mpz
        :type public: modPrimeElement
        :type *extras: mpz or int or ModPrimeElement
        :rtype: dict
        """

        __group = self.__group

        randomness = __group.random_exponent()          # r
        commitment = __group.generate(randomness)       # g ^ r

        challenge  = __group.fiatshamir(
            public,
            commitment,
            *extras)     # c = g ^ ( H( p | g | q | y | g ^ r | extras ) modq ) modp

        response = __group.add_exponents(randomness, challenge * secret) # r + c * x

        return {
            'commitment': commitment,
            'challenge': challenge,
            'response': response
        }


    def _schnorr_verify(self, proof, public, *extras):
        """
        Implementation of Schnorr protocol from the verifier's side (non-interactive)

        Validates the demonstrated proof-of-knowledge (`proof`) of the discrete logarithm of
        y (`public`). `*extras` are assumed to have been used in the Fiat-Shamir heuristic

        Provided proof has the form

        {
            'commitment': ModPrimeElement
            'challenge': mpz
            'response': mpz
        }

        :type proof: dict
        :type public: modPrimeElement
        :type *extras: mpz or int or ModPrimeElement
        """
        __group = self.__group

        commitment = proof['commitment']    # g ^ r
        challenge = proof['challenge']      # c
        response = proof['response']        # s

        # Check correctness of chalenge:
        # c == g ^ ( H( p | g | q | y | g ^ r | extras ) modq ) modp ?
        _challenge = __group.fiatshamir(
            public,
            commitment,
            *extras)

        if _challenge != challenge:
            return False

        # g ^ s modp == (g ^ r) * (y ^ c) modp ?
        return __group.generate(response) == commitment * (public ** challenge)


    # Chaum-Pedersen protocol

    def _chaum_pedersen_proof(self, ddh, z):
        """
        Implementation of Chaum-Pedersen protocol from the prover's side (non-interactive)

        Returns zero-knowledge proof that the provided 3-ple `ddh` is a DDH with respect
        to the generator g of the cryptosystem's underlying group, i.e., of the form

                        (g ^ x modp, g ^ z modp, g ^ (x * z) modp)

        for some integers 0 <= x, z < q

        The provided `ddh` is of the form

                    [ModPrimeElement, ModPrimeElement, ModPrimeElement]

        and the returned proof of the form

        {
            'base_commitment': ModPrimeElement
            'message_commitment': ModPrimeElement
            'challenge': mpz
            'response': mpz
        }

        :type ddh: list
        :type z: mpz
        :rtype: dict
        """

        __group = self.__group

        u, v, w = ddh

        randomness = __group.random_exponent()          # 1 < r < q

        g_commitment = __group.generate(randomness)     # g ^ r
        u_commitment = u ** randomness                  # u ^ r

        challenge = __group.fiatshamir(
            u, v, w,
            g_commitment,
            u_commitment)   # c = g ^ ( H( p | g | q | u | v | w | g ^ r | u ^ r ) modq ) modp

        response = __group.add_exponents(randomness, challenge * z)

        return {
            'base_commitment': g_commitment,        # g ^ r
            'message_commitment': u_commitment,     # u ^ r
            'challenge': challenge,                 # c
            'response': response                    # s = r + c * z  modq
        }


    def _chaum_pedersen_verify(self, ddh, proof):
        """
        Implementation of Chaum-Pedersen protocol from the verifier's side (non-interactive)

        Validates the demonstrated zero-knowledge `proof` that the provided 3-ple `ddh` is a
        DDH with respect to the generator g of the cryptosystem's underlying group, i.e., of
        the form
                                (u, v, g ^ (x * z) modp)

        where u = g ^ x modp, v = g ^ z modp with 0 <= x, z < q

        The provided `ddh` is of the form

                    [ModPrimeElement, ModPrimeElement, ModPrimeElement]

        and the provided `proof` of the form

        {
            'base_commitment': ModPrimeElement
            'message_commitment': ModPrimeElement
            'challenge': mpz
            'response': mpz
        }

        :type ddh: list
        :type proof: dict
        :rtype: bool
        """

        __group = self.__group

        u, v, w = ddh

        g_commitment = proof['base_commitment']         # g ^ r
        u_commitment = proof['message_commitment']      # u ^ r
        challenge = proof['challenge']                  # c
        response = proof['response']                    # s

        # Check correctness of challenge:
        # c == g ^ ( H( p | g | q | u | v | w | g ^ r | u ^ r ) modq ) modp ?
        _challenge = __group.fiatshamir(
            u, v, w,
            g_commitment,
            u_commitment)

        if _challenge != challenge:
            return False

        # Verify prover's commitment to presumed randomness:
        # g ^ s == g ^ r * v ^ c  modp ?
        if __group.generate(response) != g_commitment * (v ** challenge):
            return False

        # Verify that the provided u is of the form g ^ (k * z) for some k (and
        # thus k = x due to prover's commitment to randomness r):
        # u ^ s == u ^ r * w ^ c  modp ?
        return u ** response == u_commitment * (w ** challenge)


    # Digital Signature Algorithm

    def _dsa_signature(self, exponent, private_key):
        """
        Applies DSA to compute the digital signature of the provided `exponent` e
        (assumed to be in the range {1, ..., q - 1}) under the `private_key` x.
        Returned signature has the form

        {
            'c_1': mpz                  ((g ^ r modp) modq)
            'c_2': mpz                  ((e + x * c_1)/r modq)
        }

        for a once used randmoness r in the range {2, ..., q - 1}

        :type exponent: mpz
        :type private_key: mpz
        :rtype: dict
        """
        __group = self.__group
        __q = __group.order

        randomness = __group.random_exponent()                           # 1 < r < q
        c_1 = f_mod(__group.generate(randomness).value, __q)             # (g ^ r modp) modq

        exps = __group.add_exponents(exponent, mul(private_key, c_1))    # (e + x * c_1) modq
        r_inv = invert(randomness, __q)                                  # r ^ -1 modq
        c_2 = f_mod(mul(exps, r_inv), __q)                               # (e + x * c_1)/r modq

        signature = {'c_1': c_1, 'c_2': c_2}

        return signature


    def _dsa_verify(self, exponent, signature, public_key):
        """
        Verifies that the provded `signature` is the DSA-signature of the given
        `exponent` under the given `public_key`. Provided signature is of the form

        {
            'c_1': mpz
            'c_2': mpz
        }

        :type exponent: mpz
        :type signature: dict
        :type public_key: ModPrimeElement
        :rtype: bool
        """
        __group = self.__group
        __q = __group.order

        # Extract data from signature

        c_1 = signature['c_1']
        c_2 = signature['c_2']

        # Commitments' validity check

        for c in (c_1, c_2):
            if not 0 < c < __q:
                return False

        # Proceed to signature validation

        c_2_inv = invert(c_2, __q)                                      # c_2 ^ -1 modq

        v_1 = f_mod(mul(exponent, c_2_inv), __q)                        # (e + c_2 ^ -1) modq
        v_2 = f_mod(mul(c_1, c_2_inv), __q)                             # (v_1 * c_2 ^ -1) modq

        element = (__group.generate(v_1) * public_key ** v_2).value     # (g ^ v_1 * y ^ v_2) modp

        # ((g ^ v_1 * y ^ v_2) modp) modq == c_1 ?
        return f_mod(element, __q) == c_1


    # El-Gamal encryption

    def _encrypt(self, element, public_key, randomness=None):
        """
        Computes and returns the ElGamal ciphertext of the provided `element` m
        in the form

        {
            'alpha': ModPrimeElement        (g ^ r (modp))
            'beta': ModPrimeElement         (m * y ^ r (mod p))
        }

        where `public_key` is the receiver's public key y and r a once used
        randomness in the range {1, ..., q - 1}

        :type element: ModPrimeElement
        randomness: mpz
        :rtype: dict
        """
        __group = self.__group

        __p = __group.modulus
        __q = __group.order

        if randomness is None:
            randomness = __group.random_exponent()

        alpha = __group.generate(randomness)            # g ^ r (modp)
        beta = element * public_key ** randomness       # m * y ^ r (modp)

        ciphertxt = {'alpha': alpha, 'beta': beta}

        return ciphertxt


    def _decrypt(self, ciphertxt, private_key):
        """
        Decrypts the provided ElGamal `ciphertxt`

        {
            'alpha': ModPrimeElement        (g ^ r (modp))
            'beta': ModPrimeElement         (m * y ^ r (mod p))
        }

        under the provided `private_key` x and returns the original element

        :type ciphertxt: dict
        :type private_key: mpz
        :rtype: ModPrimeElement
        """

        alpha = ciphertxt['alpha']
        beta = ciphertxt['beta']

        original = (alpha ** private_key).inverse * beta        # (alpha ^ x) ^ -1 * beta (modp)

        return original


    def _prove_encryption(self, ciphertxt, randomness):
        """
        Generates (Schnorr) proof-of-knowledge of the `randomness` r used in the
        ElGamal encryption which yields the provided `ciphertext`. Assumes given
        ciphertext in the form

        {
            'alpha': ModPrimeElement    (g ^ r (modp))
            'beta': ModPrimeElement     (m * y ^ r (modp))
        }

        Returned proof is of the form

        {
            'commitment': ModPrimeElement,
            'challenge': mpz,
            'response': mpz
        }

        :type ciphertxt: dict
        :type original: ModPrimeElement
        :rtype: dict
        """
        alpha = ciphertxt['alpha']
        beta = ciphertxt['beta']

        proof = self._schnorr_proof(randomness, alpha, beta)

        return proof


    def _verify_encryption(self, proof, ciphertxt):
        """
        :type proof:
        :type ciphertxt:
        :rtype: bool
        """
        alpha = ciphertxt['alpha']
        beta = ciphertxt['beta']

        verified = self._schnorr_verify(proof, alpha, beta)

        return verified

    #TODO: implement
    def _decrypt_with_randomness(self, public, ciphertext, secret):
        """
        """
        pass
