from Crypto.Util.number import isPrime as is_prime
from gmpy2 import mpz, invert, powmod

from zeus_core.utils import (int_from_bytes, hash_nums, hash_texts, random_integer)
from ..abstracts import Group, GroupElement
from ..exceptions import AlgebraError


class ModPrimeElement(GroupElement):
    """
    Element of the multiplicative group Z*_p = Z_p - {0}, p > 2 prime
    """

    __slots__ = ('__value', '__modulus',)

    def __init__(self, value, modulus):
        """
        :type value: mpz
        :type modulus: mpz
        """
        self.__value = value % modulus
        self.__modulus = modulus


    @property
    def value(self):
        """
        :rtype: mpz
        """
        return self.__value


    def reset_value(self, value):
        """
        :type value: mpz
        """
        self.__value = value % self.__modulus


    def reduce_value(self, difference=1):
        """
        Reduces mod p the element's value
        """
        self.__value = (self.__value - difference) % self.__modulus


    def mirror_value(self):
        """
        Reflects mod p the element's value, i.e., if the element's
        initial value is z, then after mirroring it is equal to

        -z (mod p)
        """
        self.__value = - self.__value % self.__modulus


    def to_int(self):
        """
        :rtype: int
        """
        return int(self.__value)


    @property
    def modulus(self):
        """
        :rtype: mpz
        """
        return self.__modulus


    @property
    def inverse(self):
        """
        :rtype: ModPrimeElement
        """
        __modulus = self.__modulus
        try:
            __inverse = invert(self.__value, __modulus)
        except ZeroDivisionError:
            return
        return __class__(__inverse, __modulus)


    @property
    def bit_length(self):
        """
        :rtype: int
        """
        return self.__value.bit_length()


    def __repr__(self):
        """
        :rtype: str
        """
        return str(self.__value)


    def __hash__(self):
        """
        :rtype: int
        """
        return hash(repr(self))


    def __eq__(self, other):
        """
        :type other: ModPrimeElement or mpz
        """
        if isinstance(other, __class__):
            return self.__value == other.value
        else:
            return self.__value == other


    def __mul__(self, other):
        """
        :type other: ModPrimeElement
        """
        __modulus = self.__modulus
        result = self.__value * other.value % __modulus
        return __class__(result, __modulus)


    def __pow__(self, exp):
        """
        :type exp: mpz
        :rtype: ModPrimeElement
        """
        __modulus = self.__modulus
        result = powmod(self.__value, exp, __modulus)
        #
        # ~ result = self.__value ** exp % __modulus
        # ~ leads to overflow: "...outrageous exponent". Use gmpy2.powmod
        # ~ instead in order to avoid overflow in mpz type
        #
        return __class__(result, __modulus)


    def to_hex(self):
        """
        :rtype: str
        """
        return '%x' % self.__value


    def clone(self):
        """
        :rtype: ModPrimeElement
        """
        return __class__(self.__value, self.__modulus)


    def contained_in(self, group):
        """
        Checks if the element is contained the provided subgroup of Z*_p

        :type: Group
        :rtype: bool
        """
        if isinstance(group, ModPrimeSubgroup) and group.modulus == self.__modulus:
            #
            # ~ Algebraic fact: given the q-subgroup C of Z*_p, p > 2 prime,
            # ~ a mod p element x is contained in C iff x ^ q = 1
            #
            return self ** group.order == 1
        return False


class ModPrimeSubgroup(Group):
    """
    Subgroup of the multiplicative group Z*_p = Z_p - {0}, p > 2 prime

    There is one such group of order q for each divisor 0 < q < p - 1 of p - 1
    and is generated by the r-power, r = (p - 1)/q, of any primitive in Z*_p

    E.g., the default value r = 2 yields the group of quadratic residues modp
    """

    __slots__ = ('__modulus', '__order', '__generator', '__Element')


    def __init__(self, modulus, root_order=2):
        """
        """
        modulus = modulus
        root_order = root_order

        if modulus <= 2 or not is_prime(modulus):
            err = "Provided modulus is not an odd prime"
            raise AlgebraError(err)

        if root_order <= 0 or root_order >= modulus:
            err = "Provided order of unit root is not in the allowed range"
            raise AlgebraError(err)

        order, s = divmod(modulus - 1, root_order)

        if s != 0:
            err = "Provided order of unit root does not divide the group\'s order"
            raise AlgebraError(err)

        self.__modulus = modulus
        self.__order = order

        self.__Element = ModPrimeElement
        self.__unit = mpz(1)


    def __repr__(self):
        """
        :rtype: str
        """
        return '%s (%d, %d)' % (__class__, self.__modulus, self.__order)

    def __hash__(self):
        """
        :rtype: str
        """
        return hash(repr(self))


    @property
    def modulus(self):
        """
        :rtype: mpz
        """
        return self.__modulus


    @property
    def order(self):
        """
        :rtype: mpz
        """
        return self.__order


    @property
    def generator(self):
        """
        :rtype: ModPrimeElement
        """
        try:
            return self.__generator
        except AttributeError:
            err = "No generator has been yet specified for this group"
            raise AlgebraError(err)


    def parameters(self):
        """
        """
        p = self.__modulus
        q = self.__order
        g = self.__generator.value
        return p, q, g


    @property
    def Element(self):
        """
        :rtype: class
        """
        return self.__Element


    @property
    def unit(self):
        """
        Returns the unit element of the group (i.e., the neutral
        element with respect to the group operation)

        :rtype: ModPrimeElement
        """
        return self.__Element(self.__unit, self.__modulus)


    def set_generator(self, generator):
        """
        :type generator: ModPrimeElement or mpz
        """
        Element = self.__Element
        if isinstance(generator, Element):
            self.__generator = generator
        else:
            self.__generator = Element(generator, self.__modulus)


    def generate(self, exponent):
        """
        :type exponent: mpz
        :rtype: ModPrimeElement
        """
        return self.__generator ** exponent


    def add_exponents(self, *args):
        """
        :type *args: mpz
        :rtype: mpz
        """
        return sum(args) % self.__order


    def random_exponent(self, min=2):
        """
        Returns a random exponent >= `min`, bounded by the group's order

        :rtype: mpz
        """
        exponent = random_integer(min, self.__order)
        return exponent


    def exponent_from_texts(self, *texts):
        """
        :type *texts: str
        :rtype: mpz
        """
        __p, __q, __g = self.parameters()

        hashed_params = hash_nums(__p, __q, __g).hex()
        hashed_texts = hash_texts(hashed_params, *texts)
        exponent = int_from_bytes(hashed_texts)
        exponent = exponent % __q

        return exponent


    def random_element(self):
        """
        :rtype: ModPrimeElement
        """
        random_exp = self.random_exponent()
        return self.__generator ** random_exp


    def element_from_texts(self, *texts):
        """
        :type *texts: str
        :rtype: ModPrimeElement
        """
        exp = self.exponent_from_texts(*texts)
        return self.generate(exp)


    def fiatshamir(self, *elements):
        """
        The output of this method is only involved in exponent operations

        :type: mpz or ModePrimeElement
        :rtype: mpz
        """
        __p, __q, __g = self.parameters()

        elements = (_.value if isinstance(_, ModPrimeElement) else _ \
            for _ in elements)

        digest = hash_nums(__p, __q, __g, *elements)
        reduced = int_from_bytes(digest)
        output = self.generate(reduced).value

        return output                    # g ^ ( H( p | g | q | elements)  modq )  modp


    def contains(self, element):
        """
        Checks if the group contains the provided element of Z*_p

        :type element: GroupElement
        :rtype: bool
        """
        if isinstance(element, ModPrimeElement) and element.modulus == self.__modulus:
            #
            # ~ Algebraic fact: given the q-subgroup C of Z*_p, p > 2 prime,
            # ~ a mod p element x is contained in C iff x ^ q = 1
            #
            return element ** self.__order == 1
        return False


    def encode_integer(self, integer):
        """
        Encodes the provided `integer` x from the range 0 < x + 1 < q - 1
        as a modp element with the value

                                (x + 1) mod p

        if this happens to be r-residue modp, otherwise with the mirror value

                              - (x + 1) mod p

        .. raises:: AlgebraError if x is not in the specified range

        :type integer: int
        :rtype: ModPrimeElement

        .. note:: The result of this encoding is not necessarilly contained
        in the present group, even after mirroring its value modp
        """
        __modulus, __order, _ = self.parameters()

        integer += 1
        if not 0 < integer < __order:
            err = 'Provided integer is not in the allowed range'
            raise AlgebraError(err)

        value = mpz(integer)

        encoded = self.__Element(value, __modulus)
        if not self.contains(encoded):
            encoded.mirror_value()

        return encoded


    def decode_with_randomness(self, encoded):
        """
        Given a mod p element with value z, it returns the element

                                z - 1 (mod p)

        if z's numerical value happens to be smaller than the order
        of the present subgroup; otherwise the element

                            (-z (mod p)) - 1 (mod p)

        is returned.

        :type element: ModPrimeElement
        :rtype: int
        """
        decoded = encoded.clone()
        if decoded.value >= self.__order:
            decoded.mirror_value()
        decoded.reduce_value()
        return decoded
